PluggableTextMorph subclass: #LinesCounter	instanceVariableNames: 'completedLines'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!LinesCounter methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 10/31/2012 21:51'!initialize	| f |	super initialize.	f := LogicalFont familyName: 'Arial' pointSize: 50.	completedLines := 0.	self		setText: completedLines asString;		font: f;		wrapFlag: true;		extent: 200@200;		color: Color transparent;		borderWidth: 0;		textColor: Color white.! !!LinesCounter methodsFor: 'accessing' stamp: 'PaoloBoschini 11/26/2010 14:52'!incrementCounter	completedLines := completedLines + 1.	self setText: completedLines asString.! !Morph subclass: #Sprite	instanceVariableNames: 'velocity angle allSubMorphsButMeCells allSubMorphsCells toAnimate spriteBottomCells toDrop bottomComplete'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 18:38'!cell	| c |	c := Cell new.	c extent: (50@50).	(self isKindOf: I) ifTrue: [c color: Color lightBlue].	(self isKindOf: J) ifTrue: [c color: Color blue].	(self isKindOf: L) ifTrue: [c color: Color orange].	(self isKindOf: O) ifTrue: [c color: Color yellow].	(self isKindOf: S) ifTrue: [c color: Color green].	(self isKindOf: Z) ifTrue: [c color: Color red].	(self isKindOf: T) ifTrue: [c color: Color brown].	^c.! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 18:54'!checkCollision		| allSubMorphsButMe container collidedMorph |	container := self owner.			"get a list of all morphs but me"	allSubMorphsButMe := container submorphs select: [ :e | e ~= self ].	"check if I've' collided"	self submorphs do: [:myCell | 		collidedMorph isNil ifTrue: [			collidedMorph := allSubMorphsButMe				detect: [ :cell | 					cell top = myCell bottom						and: [ (myCell left >= cell left and: [ myCell left < cell right ]) or: [ myCell right > cell left and: [ myCell right <= cell right ] ] ] ]				ifNone: [  ].			].		].	"if the list is not empty, I have collided, stop stepping and create a new Sprite"	collidedMorph isNil		ifFalse: [  			self stopStepping.			"check if gameover"			(self top < 30) ifTrue: [				"container addMorph: (Container gameover: (owner center))."				TetrisGame gameover.				^false			].						self checkLine.			container addSprite ]! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 18:53'!checkLine	"called whenever a sprite stops dropping"	"this method adds the subcells of each sprite to the container	so that they can be removed from itself"	| container v toRemove removedLines |	container := self owner.	spriteBottomCells removeAll.	toDrop removeAll.	bottomComplete removeAll.	removedLines := 0.	"at what position the cells have stopped"	self submorphs do: [ :cell | spriteBottomCells add: cell bottom ].	self submorphs do: [ :cell | (container cellsCompleteTheLine includesKey: cell bottom)		ifFalse: [			container cellsCompleteTheLine at: cell bottom put: 1		]		ifTrue: [			v := container cellsCompleteTheLine at: cell bottom.			container cellsCompleteTheLine at: cell bottom put: v + 1		]	].	"move the submorphs from the sprite to the container"	self submorphs do: [ :cell | container addMorph: cell ].	container removeMorph: self.	"check if completed line"	spriteBottomCells do: [ :bottom | 		(container cellsCompleteTheLine at: bottom) = 10 ifTrue: [ 			bottomComplete add: bottom.			container cellsCompleteTheLine at: bottom put: 0.			removedLines := removedLines + 1.						"contains cells to be removed"			toRemove := container submorphs select: [ :e | e bottom = bottom ].						"magically remove cells by the container"			toRemove do: [ :e | World addMorph: e. e startStepping ].			"update line counter"			TetrisGame lineCounter incrementCounter.		]	].	"drop the cells above the removed ones"	removedLines > 0 ifTrue: [ 		"select the cells to be dropped"		"toDrop is a collection of arrays"		bottomComplete do: [ :b | toDrop add: (container submorphs select: [ :e | e bottom < b ])].		"move the cells"		toDrop do: [:array | array do: [:cell | cell position: cell position + (0 @ 50) ]].				"repopulate the dictionary"		container cellsCompleteTheLine removeAll.		self populateDictionary: container	]! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 20:19'!handleKeyDown: anEvent	anEvent keyValue = 125 "down"		ifTrue: [velocity := 50. self startStepping].! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 20:19'!handleKeyUp: anEvent	anEvent keyValue = 125 "down"		ifTrue: [velocity := 700].! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:30'!handleKeystroke: anEvent	| allSubMorphsButMe collidedMorph |	"up"	anEvent keyValue = 30		ifTrue: [ self rotate ].			"right"	anEvent keyValue = 29		ifTrue: [ 			self right < self owner right				ifTrue: [ 					"get a list of all morphs but me"					allSubMorphsButMe := self owner submorphs select: [ :e | e ~= self ]					"check if I collide".					self submorphs						do: [ :myCell | 							collidedMorph isNil								ifTrue: [ collidedMorph := allSubMorphsButMe detect: [ :cell | cell left = myCell right & (cell top = myCell top) ] ifNone: [  ] ] ].					collidedMorph isNil						ifTrue: [ self position: self position + (50 @ 0) ] "right" ] ].	"left"	anEvent keyValue = 28		ifTrue: [ 			self left > self owner left				ifTrue: [ 					"get a list of all morphs but me"					allSubMorphsButMe := self owner submorphs select: [ :e | e ~= self ]					"check if I collide".					self submorphs						do: [ :myCell | 							collidedMorph isNil								ifTrue: [ collidedMorph := allSubMorphsButMe detect: [ :cell | cell right = myCell left & (cell top = myCell top) ] ifNone: [  ] ] ].					collidedMorph isNil						ifTrue: [ self position: self position - (50 @ 0) ] "left" ] ].	"pause"	anEvent keyValue = Character space asciiValue		ifTrue: [ self isStepping ifTrue: [self stopStepping] ifFalse: [self startStepping] ]! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:23'!initialize	super initialize.	velocity := 700.	angle := 0.		spriteBottomCells := Set new.	toDrop := OrderedCollection new.	bottomComplete := Set new! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 19:41'!populateDictionary: container	| v |	container submorphs		do: [ :cell | 			(container cellsCompleteTheLine includesKey: cell bottom)				ifFalse: [ container cellsCompleteTheLine at: cell bottom put: 1 ]				ifTrue: [ 					v := container cellsCompleteTheLine at: cell bottom.					container cellsCompleteTheLine at: cell bottom put: v + 1 ] ]! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:32'!rotate	angle := angle + 90.	angle = 360		ifTrue: [ angle := 0 ].	self setCells: angle! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 18:52'!step	| container |	container := self owner.	"drop until reaches the bottom, otherwise stop dropping"	self bottom = container bottom		ifTrue: [ 			self				stopStepping;				checkLine.			container addSprite.			^ false ]		ifFalse: [ self position: self position + (0 @ 50) ].	"if I haven't reached the bottom I must have collided"	self checkCollision! !!Sprite methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/4/2010 21:28'!stepTime	^velocity! !Sprite subclass: #J	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!J methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/7/2010 22:26'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!J methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:33'!rotate	"check if I end up outside the container"	((angle = 90) | (angle = 270)) & (self right = (self owner right)) ifTrue: [^self]. 	super rotate.! !!J methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:34'!setCells: degree	self removeAllMorphs.	degree = 0		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (100 @ 50)). ].	degree = 90		ifTrue: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (0 @ 100)).			self addMorph: (self cell position: self position + (50 @ 0)) ].	degree = 180		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (100 @ 0)).			self addMorph: (self cell position: self position + (100 @ 50)) ].	degree = 270		ifTrue: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (50 @ 100)).			self addMorph: (self cell position: self position + (0 @ 100)) ]! !Sprite subclass: #L	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!L methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/4/2010 21:21'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!L methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:34'!rotate	"check if I end up outside the container"	((angle = 90) | (angle = 270)) & (self right = (self owner right)) ifTrue: [^self]. 	super rotate.! !!L methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:34'!setCells: degree	self removeAllMorphs.	degree = 0		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (100 @ 50)).			self addMorph: (self cell position: self position + (100 @ 0)) ].	degree = 90		ifTrue: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (0 @ 100)).			self addMorph: (self cell position: self position + (50 @ 100)) ].	degree = 180		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (100 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)) ].	degree = 270		ifTrue: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (50 @ 100)) ]! !Sprite subclass: #O	instanceVariableNames: 'position'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!O methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/5/2010 20:21'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!O methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/5/2010 20:19'!setCells: degree	self extent: 100 @ 100.	self addMorph: (self cell position: self position).	self addMorph: (self cell position: self position + (50 @ 0)).	self addMorph: (self cell position: self position + (0 @ 50)).	self addMorph: (self cell position: self position + (50 @ 50))! !Sprite subclass: #Z	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Z methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/7/2010 23:07'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!Z methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:35'!rotate	"check if I end up outside the container"	((angle = 90) | (angle = 270)) & (self right = (self owner right)) ifTrue: [^self]. 	super rotate.! !!Z methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:35'!setCells: degree	self removeAllMorphs.	(degree = 0) | (degree = 180)		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (100 @ 50)) ]		ifFalse: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (0 @ 100)) ].! !PluggableButtonMorph subclass: #CloseButton	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!CloseButton methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/24/2012 23:56'!initialize	super initialize.	self		model: TetrisGame;		action: #close;		label: 'Quit Game';		extent: 100@40;		topLeft: TetrisGame container topRight + (100@350).						"self on: TetrisGame getState: nil action: #close"	"		target: TetrisGame;		label: 'Quit Game';		actionSelector: #close;		extent: 100@50."! !Sprite subclass: #T	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!T methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/7/2010 23:10'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!T methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:35'!rotate	"check if I end up outside the container"	((angle = 90) | (angle = 270)) & (self right = (self owner right)) ifTrue: [^self]. 	super rotate.! !!T methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:35'!setCells: degree	self removeAllMorphs.	degree = 0		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (100 @ 50)).			self addMorph: (self cell position: self position + (50 @ 0)) ].	degree = 90		ifTrue: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (0 @ 100)).			self addMorph: (self cell position: self position + (50 @ 50)) ].	degree = 180		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (100 @ 0)).			self addMorph: (self cell position: self position + (50 @ 50)) ].	degree = 270		ifTrue: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (50 @ 100)).			self addMorph: (self cell position: self position + (0 @ 50)) ]! !BorderedMorph subclass: #TetrisGame	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TetrisGame class	instanceVariableNames: 'lineCounter background closeButton container'!!TetrisGame class methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/16/2010 22:09'!createBorderLineFrom: p1 to: p2	^ LineMorph		from: p1		to: p2		color: Color white		width: 10! !!TetrisGame class methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/25/2012 00:22'!gameover	| f |	f := LogicalFont familyName: 'Arial' pointSize: 120.	background		addMorph:			(PluggableTextMorph new				setText: 'GAME OVER';				font: f;				wrapFlag: true;				color: Color white;				extent: 200 @ 100;				borderWidth: 0;				center: World topCenter + (0 @ 400))! !!TetrisGame class methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/24/2012 23:58'!start	container := Container new.	closeButton := CloseButton new.	lineCounter := LinesCounter new position: container topRight + (100@400).	background := FullscreenMorph new		color: Color gray;		addMorph: container;		addMorph: closeButton;		addMorph: lineCounter.	"	background := ImageMorph withForm: (Form fromFileNamed: 'picture.jpg').	background extent: World extent.""	background addMorph: c.	background addMorph: ((self createBorderLineFrom: c bottomLeft to: c bottomRight) top: c bottom).	background addMorph: ((self createBorderLineFrom: c bottomLeft to: c topLeft) right: c left).	background addMorph: ((self createBorderLineFrom: c topLeft to: c topRight) bottom: c top).	background addMorph: ((self createBorderLineFrom: c topRight to: c bottomRight) left: c right)."	"background addMorph: (Morph new extent: 130@90; position: c topRight + (100@400); color: Color black; borderWidth: 5; borderColor: Color white).	background addMorph: lineCounter."	background openInWorld.	container addSprite! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/28/2010 19:00'!background	^ background! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/28/2010 19:00'!background: anObject	background := anObject! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/24/2012 23:10'!close	Container allInstances do: [ :e | e delete ].	Sprite allInstances do: [ :e | e delete ].	Cell allInstances do: [ :e | e delete ].	background delete.	Smalltalk garbageCollect.! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/24/2012 23:49'!closeButton	^ closeButton! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/24/2012 23:49'!closeButton: anObject	closeButton := anObject! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/24/2012 23:49'!container	^ container! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/24/2012 23:49'!container: anObject	container := anObject! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/26/2010 15:09'!lineCounter	^ lineCounter! !!TetrisGame class methodsFor: 'accessing' stamp: 'PaoloBoschini 11/26/2010 15:09'!lineCounter: anObject	lineCounter := anObject! !Sprite subclass: #S	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!S methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/7/2010 22:59'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!S methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:34'!rotate	"check if I end up outside the container"	((angle = 90) | (angle = 270)) & (self right = (self owner right)) ifTrue: [^self]. 	super rotate.! !!S methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:35'!setCells: degree		self removeAllMorphs.	(degree = 0) | (degree = 180)		ifTrue: [ 			self extent: 150 @ 100.			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (100 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (50 @ 50)) ]		ifFalse: [ 			self extent: 100 @ 150.			self addMorph: (self cell position: self position + (0 @ 0)).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (50 @ 50)).			self addMorph: (self cell position: self position + (50 @ 100)) ].! !BorderedMorph subclass: #Container	instanceVariableNames: 'droppingSprite nextSprite cellsCompleteTheLine'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Container methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 20:13'!addSprite	| newSprite |	nextSprite isNil	ifTrue: [		newSprite := self createSprite.		self addMorph: newSprite.		newSprite takeKeyboardFocus.	]	ifFalse: [		nextSprite position: self position + (150 @ -50).		self addMorph: nextSprite.		nextSprite startStepping.		nextSprite takeKeyboardFocus.	].	self createNextSprite.! !!Container methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 19:35'!cellsCompleteTheLine	^ cellsCompleteTheLine! !!Container methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/16/2010 21:49'!createNextSprite	nextSprite := self createSprite.	(self owner) addMorph: nextSprite.	nextSprite		topLeft: self topRight + 100;		stopStepping.	! !!Container methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 20:02'!createSprite	^ (Sprite subclasses at: (Random new nextInt: Sprite subclasses size)) new position: self position + (150 @ -50)! !!Container methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 10/31/2012 23:10'!initialize	super initialize.	cellsCompleteTheLine := Dictionary new.	nextSprite := nil.	self		extent: 500 @ 700;		center: World center;		color: Color transparent;		borderColor: Color green;		color: Color black;		borderWidth: 0.! !BorderedMorph subclass: #Cell	instanceVariableNames: 'colorAlpha'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Cell methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/28/2010 17:00'!initialize	"Cell new openInHand."	super initialize.	self borderColor: Color gray.	colorAlpha := 1.! !!Cell methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:24'!step		"Start the animation for fading me out"		self		"position: self position - (0@(Random new nextInt: 10));"		position: self position - (0@20);		borderWidth: 0;		color: (self color alpha: colorAlpha).	colorAlpha := colorAlpha - 0.1.	colorAlpha < 0.1 ifTrue: [World removeMorph: self. ].! !!Cell methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:24'!stepTime	^10! !!Cell methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/7/2010 01:07'!wantsSteps	^false! !Sprite subclass: #I	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!I methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/4/2010 21:21'!initialize	super initialize.	self color: Color transparent.	self setCells: angle.! !!I methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:33'!rotate	"check if I end up outside the container"	((angle = 0) | (angle = 180)) & (self left > 690) ifTrue: [^self].	super rotate.! !!I methodsFor: 'as yet unclassified' stamp: 'PaoloBoschini 11/14/2012 20:33'!setCells: degree	self removeAllMorphs.	(degree = 0) | (degree = 180)		ifTrue: [ 			self extent: 50@200.			self addMorph: (self cell position: self position).			self addMorph: (self cell position: self position + (0 @ 50)).			self addMorph: (self cell position: self position + (0 @ 100)).			self addMorph: (self cell position: self position + (0 @ 150)) ]		ifFalse: [ 			self extent: 200@50.			self addMorph: (self cell position: self position).			self addMorph: (self cell position: self position + (50 @ 0)).			self addMorph: (self cell position: self position + (100 @ 0)).			self addMorph: (self cell position: self position + (150 @ 0)) ]! !